# HG changeset patch
# User Chris Coulson
# Parent 0ebe30f9eacfe67fa0b699457e524d5a9c96359e
Bug 611953 - GNOME 3.0 readiness (patch 2 + 3)

diff --git a/toolkit/system/gnome/nsGIOService.cpp b/toolkit/system/gnome/nsGIOService.cpp
--- a/toolkit/system/gnome/nsGIOService.cpp
+++ b/toolkit/system/gnome/nsGIOService.cpp
@@ -101,25 +101,25 @@ nsGIOMimeApp::GetName(nsACString& aName)
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsGIOMimeApp::GetCommand(nsACString& aCommand)
 {
   get_commandline_t g_app_info_get_commandline_ptr;
 
-  void *libHandle = dlopen("libgio-2.0.so", RTLD_LAZY);
+  void *libHandle = dlopen("libgio-2.0.so.0", RTLD_LAZY);
   if (!libHandle) {
     return NS_ERROR_FAILURE;
   }
   dlerror(); /* clear any existing error */
   g_app_info_get_commandline_ptr =
     (get_commandline_t) dlsym(libHandle, "g_app_info_get_commandline");
-  if (dlerror() != NULL) {
-    const char cmd = *g_app_info_get_commandline_ptr(mApp);
+  if (dlerror() == NULL) {
+    const char *cmd = g_app_info_get_commandline_ptr(mApp);
     if (!cmd) {
       dlclose(libHandle);
       return NS_ERROR_FAILURE;
     }
     aCommand.Assign(cmd);
   }
   dlclose(libHandle);
   return NS_OK;
@@ -277,16 +277,43 @@ nsGIOMimeApp::SetAsDefaultForFileExtensi
     } else {
       *ext_pos = '\0';
     }
   }
   g_free(extensions);
   return NS_OK;
 }
 
+/**
+ * Set default application for URI's of a particular scheme
+ * @param aURIScheme string containing the URI scheme
+ * @return NS_OK when application was set as default for URI scheme,
+ * NS_ERROR_FAILURE otherwise
+ */
+NS_IMETHODIMP
+nsGIOMimeApp::SetAsDefaultForURIScheme(nsACString const& aURIScheme)
+{
+  GError *error = NULL;
+  nsCAutoString contentType("x-scheme-handler/");
+  contentType.Append(aURIScheme);
+
+  g_app_info_set_as_default_for_type(mApp,
+                                     contentType.get(),
+                                     &error);
+  if (error) {
+    g_warning("Cannot set application as default for URI scheme (%s): %s",
+              PromiseFlatCString(aURIScheme).get(),
+              error->message);
+    g_error_free(error);
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 nsresult
 nsGIOService::Init()
 {
   // do nothing, gvfs/gio does not init.
   return NS_OK;
 }
 
 NS_IMPL_ISUPPORTS1(nsGIOService, nsIGIOService)
@@ -317,29 +344,45 @@ nsGIOService::GetMimeTypeFromExtension(c
   g_free(mime_type);
   g_free(content_type);
 
   return NS_OK;
 }
 // used in nsGNOMERegistry
 // -----------------------------------------------------------------------------
 NS_IMETHODIMP
+nsGIOService::GetAppForURIScheme(const nsACString& aURIScheme,
+                                 nsIGIOMimeApp** aApp)
+{
+  *aApp = nsnull;
+
+  GAppInfo *app_info = g_app_info_get_default_for_uri_scheme(
+                         PromiseFlatCString(aURIScheme).get());
+  if (app_info) {
+    nsGIOMimeApp *mozApp = new nsGIOMimeApp(app_info);
+    NS_ADDREF(*aApp = mozApp);
+  } else {
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsGIOService::GetAppForMimeType(const nsACString& aMimeType,
                                 nsIGIOMimeApp**   aApp)
 {
   *aApp = nsnull;
   char *content_type =
     get_content_type_from_mime_type(PromiseFlatCString(aMimeType).get());
   if (!content_type)
     return NS_ERROR_FAILURE;
 
   GAppInfo *app_info = g_app_info_get_default_for_type(content_type, false);
   if (app_info) {
     nsGIOMimeApp *mozApp = new nsGIOMimeApp(app_info);
-    NS_ENSURE_TRUE(mozApp, NS_ERROR_OUT_OF_MEMORY);
     NS_ADDREF(*aApp = mozApp);
   } else {
     g_free(content_type);
     return NS_ERROR_FAILURE;
   }
   g_free(content_type);
   return NS_OK;
 }
@@ -414,75 +457,46 @@ nsGIOService::CreateAppFromCommand(nsACS
                                    nsIGIOMimeApp**   appInfo)
 {
   GError *error = NULL;
   *appInfo = nsnull;
 
   GAppInfo *app_info = NULL, *app_info_from_list = NULL;
   GList *apps = g_app_info_get_all();
   GList *apps_p = apps;
-  get_commandline_t g_app_info_get_commandline_ptr;
-
-  void *libHandle = dlopen("libgio-2.0.so", RTLD_LAZY);
-  if (!libHandle) {
-    return NS_ERROR_FAILURE;
-  }
-  dlerror(); /* clear any existing error */
-  g_app_info_get_commandline_ptr =
-    (get_commandline_t) dlsym(libHandle, "g_app_info_get_commandline");
-  if (dlerror() != NULL) {
-    g_app_info_get_commandline_ptr = NULL;
-  }
 
   // Try to find relevant and existing GAppInfo in all installed application
+  // We do this by comparing each GAppInfo's executable with out own
   while (apps_p) {
     app_info_from_list = (GAppInfo*) apps_p->data;
-    /* This is  a silly test. It just compares app names but not
-     * commands. This is due to old version of Glib/Gio. The required
-     * function which allows to do a regular check of existence of desktop file
-     * is possible by using function g_app_info_get_commandline. This function
-     * has been introduced in Glib 2.20. */
-    if (app_info_from_list && strcmp(g_app_info_get_name(app_info_from_list),
-                                     PromiseFlatCString(appName).get()) == 0 )
-    {
-      if (g_app_info_get_commandline_ptr)
-      {
-        /* Following test is only possible with Glib >= 2.20.
-         * Compare path only by using strncmp */
-        if (strncmp(g_app_info_get_commandline_ptr(app_info_from_list),
-                    PromiseFlatCString(cmd).get(),
-                    strlen(PromiseFlatCString(cmd).get())) == 0)
-        {
-          app_info = app_info_from_list;
-          break;
-        } else {
-          g_object_unref(app_info_from_list);
-        }
-      } else {
+    if (!app_info) {
+      // If the executable is not absolute, get it's full path
+      char *executable = g_find_program_in_path(g_app_info_get_executable(app_info_from_list));
+
+      if (executable && strcmp(executable, PromiseFlatCString(cmd).get()) == 0) {
+        g_object_ref (app_info_from_list);
         app_info = app_info_from_list;
-        break;
       }
-    } else {
-      g_object_unref(app_info_from_list);
+      g_free(executable);
     }
+
+    g_object_unref(app_info_from_list);
     apps_p = apps_p->next;
   }
   g_list_free(apps);
 
   if (!app_info) {
     app_info = g_app_info_create_from_commandline(PromiseFlatCString(cmd).get(),
                                                   PromiseFlatCString(appName).get(),
                                                   G_APP_INFO_CREATE_SUPPORTS_URIS,
                                                   &error);
   }
 
   if (!app_info) {
     g_warning("Cannot create application info from command: %s", error->message);
     g_error_free(error);
-    dlclose(libHandle);
     return NS_ERROR_FAILURE;
   }
   nsGIOMimeApp *mozApp = new nsGIOMimeApp(app_info);
   NS_ENSURE_TRUE(mozApp, NS_ERROR_OUT_OF_MEMORY);
   NS_ADDREF(*appInfo = mozApp);
-  dlclose(libHandle);
   return NS_OK;
 }
diff --git a/xpcom/system/nsIGIOService.idl b/xpcom/system/nsIGIOService.idl
--- a/xpcom/system/nsIGIOService.idl
+++ b/xpcom/system/nsIGIOService.idl
@@ -39,17 +39,17 @@
 
 #include "nsISupports.idl"
 
 interface nsIUTF8StringEnumerator;
 interface nsIURI;
 
 /* nsIGIOMimeApp holds information about an application that is looked up
    with nsIGIOService::GetAppForMimeType. */
-// 66009894-9877-405b-9321-bf30420e34e6 prev uuid
+// e77021b4-4012-407d-b686-7a1f18050109 prev uuid
 
 [scriptable, uuid(e77021b4-4012-407d-b686-7a1f18050109)] 
 interface nsIGIOMimeApp : nsISupports
 {
   const long EXPECTS_URIS  = 0;
   const long EXPECTS_PATHS = 1;
   const long EXPECTS_URIS_FOR_NON_FILES = 2;
 
@@ -57,41 +57,45 @@ interface nsIGIOMimeApp : nsISupports
   readonly attribute AUTF8String         name;
   readonly attribute AUTF8String         command;
   readonly attribute long                expectsURIs;  // see constants above
   readonly attribute nsIUTF8StringEnumerator supportedURISchemes;
 
   void launch(in AUTF8String uri);
   void setAsDefaultForMimeType(in AUTF8String mimeType);
   void setAsDefaultForFileExtensions(in AUTF8String extensions);
+  void setAsDefaultForURIScheme(in AUTF8String uriScheme);
 };
 
 /*
  * The VFS service makes use of two distinct registries.
  *
  * The application registry holds information about applications (uniquely
  * identified by id), such as which MIME types and URI schemes they are
  * capable of handling, whether they run in a terminal, etc.
  *
  * The MIME registry holds information about MIME types, such as which
  * extensions map to a given MIME type.  The MIME registry also stores the
  * id of the application selected to handle each MIME type.
  */
 
-// prev id dea20bf0-4e4d-48c5-b932-dc3e116dc64b
-[scriptable, uuid(47e372c2-78bb-4899-8114-56aa7d9cdac5)]
+// prev id 47e372c2-78bb-4899-8114-56aa7d9cdac5
+[scriptable, uuid(74ca8791-330d-4786-9569-2a2a19f0b486)]
 interface nsIGIOService : nsISupports
 {
 
   /*** MIME registry methods ***/
 
   /* Obtain the MIME type registered for an extension.  The extension
      should not include a leading dot. */
   AUTF8String        getMimeTypeFromExtension(in AUTF8String extension);
 
+  /* Obtain the preferred application for opening a given URI scheme */
+  nsIGIOMimeApp      getAppForURIScheme(in AUTF8String aURIScheme);
+
   /* Obtain the preferred application for opening a given MIME type */
   nsIGIOMimeApp      getAppForMimeType(in AUTF8String mimeType);
 
   /* Obtain the preferred application for opening a given MIME type */
   nsIGIOMimeApp      createAppFromCommand(in AUTF8String cmd, 
                                           in AUTF8String appName);
 
   /* Obtain a description for the given MIME type */
