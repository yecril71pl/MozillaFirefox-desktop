Index: mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in
===================================================================
--- mozilla.orig/xpcom/reflect/xptcall/src/md/unix/Makefile.in
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in
@@ -278,7 +278,7 @@ endif
 #
 # Linux/PPC64
 #
-ifneq (,$(filter Linuxpowerpc64 FreeBSDpowerpc64,$(OS_ARCH)$(OS_TEST)))
+ifneq (,$(filter Linuxpowerpc64 Linuxpowerpc64le FreeBSDpowerpc64,$(OS_ARCH)$(OS_TEST)))
 CPPSRCS                := xptcinvoke_ppc64_linux.cpp xptcstubs_ppc64_linux.cpp
 ASFILES                := xptcinvoke_asm_ppc64_linux.s xptcstubs_asm_ppc64_linux.s
 AS             := $(CC) -c -x assembler-with-cpp
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc64_linux.s
===================================================================
--- mozilla.orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc64_linux.s
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc64_linux.s
@@ -17,12 +17,29 @@
 .set f25,25; .set f26,26; .set f27,27; .set f28,28; .set f29,29
 .set f30,30; .set f31,31
 
+#if _CALL_ELF == 2
+#define STACK_TOC      28
+#define STACK_PARAMS   96
+#else
+#define STACK_TOC      40
+#define STACK_PARAMS   112
+#endif
 
 #
 # NS_InvokeByIndex_P(nsISupports* that, uint32_t methodIndex,
 #                    uint32_t paramCount, nsXPTCVariant* params)
 #
 
+#if _CALL_ELF == 2
+        .section ".text"
+        .type   NS_InvokeByIndex_P,@function
+        .globl  NS_InvokeByIndex_P
+        .align 2
+NS_InvokeByIndex_P:
+0:      addis 2,12,(.TOC.-0b)@ha
+        addi 2,2,(.TOC.-0b)@l
+        .localentry NS_InvokeByIndex_P,.-NS_InvokeByIndex_P
+#else
         .section ".toc","aw"
         .section ".text"
         .align 2
@@ -34,6 +51,7 @@ NS_InvokeByIndex_P:
         .previous
         .type   NS_InvokeByIndex_P,@function
 .NS_InvokeByIndex_P:
+#endif
         mflr    0
         std     0,16(r1)
 
@@ -56,7 +74,7 @@ NS_InvokeByIndex_P:
         #                               (-23*8).(-16*8).(-3*8)..(r31)
 
         # +stack frame, -unused stack params, +regs storage, +1 for alignment
-        addi    r7,r5,((112/8)-7+7+13+3+1)
+        addi    r7,r5,((STACK_PARAMS/8)-7+7+13+3+1)
         rldicr  r7,r7,3,59              # multiply by 8 and mask with ~15
         neg     r7,r7
         stdux   r1,r1,r7
@@ -72,7 +90,7 @@ NS_InvokeByIndex_P:
 
         subi    r3,r31,(23*8)           # r3 --> GPRS
         subi    r4,r31,(16*8)           # r4 --> FPRS
-        addi    r7,r1,112               # r7 --> params
+        addi    r7,r1,STACK_PARAMS      # r7 --> params
         bl      invoke_copy_to_stack
         nop
 
@@ -83,14 +101,18 @@ NS_InvokeByIndex_P:
 
         sldi    r30,r30,3               # Find function descriptor 
         add     r9,r9,r30
-        ld      r9,0(r9)
+        ld      r12,0(r9)
 
-        ld      r0,0(r9)                # Actual address from fd.
-        std     r2,40(r1)               # Save r2 (TOC pointer)
+        std     r2,STACK_TOC(r1)        # Save r2 (TOC pointer)
 
+#if _CALL_ELF == 2
+        mtctr   r12
+#else
+        ld      r0,0(r12)               # Actual address from fd.
         mtctr   0
-        ld      r11,16(r9)              # Environment pointer from fd.
-        ld      r2,8(r9)                # TOC pointer from fd.
+        ld      r11,16(r12)             # Environment pointer from fd.
+        ld      r2,8(r12)               # TOC pointer from fd.
+#endif
 
         # Load FP and GP registers as required
         ld      r4, -(23*8)(r31) 
@@ -117,7 +139,7 @@ NS_InvokeByIndex_P:
 
         bctrl                           # Do it
 
-        ld      r2,40(r1)               # Load our own TOC pointer
+        ld      r2,STACK_TOC(r1)        # Load our own TOC pointer
         ld      r1,0(r1)                # Revert stack frame
         ld      0,16(r1)                # Reload lr
         ld      29,-24(r1)              # Restore NVGPRS
@@ -126,7 +148,11 @@ NS_InvokeByIndex_P:
         mtlr    0
         blr
 
+#if _CALL_ELF == 2
+        .size   NS_InvokeByIndex_P,.-NS_InvokeByIndex_P
+#else
         .size   NS_InvokeByIndex_P,.-.NS_InvokeByIndex_P
+#endif
 
         # Magic indicating no need for an executable stack
         .section .note.GNU-stack, "", @progbits ; .previous
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_ppc64_linux.cpp
===================================================================
--- mozilla.orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_ppc64_linux.cpp
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_ppc64_linux.cpp
@@ -74,7 +74,9 @@ invoke_copy_to_stack(uint64_t* gpregs,
                 fpregs[i]   = s->val.f; // if passed in registers, floats are promoted to doubles
             } else {
                 float *p = (float *)d;
+#ifndef __LITTLE_ENDIAN__
                 p++;
+#endif
                 *p = s->val.f;
             }
         }
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_ppc64_linux.s
===================================================================
--- mozilla.orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_ppc64_linux.s
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_ppc64_linux.s
@@ -17,6 +17,27 @@
 .set f25,25; .set f26,26; .set f27,27; .set f28,28; .set f29,29
 .set f30,30; .set f31,31
 
+#if _CALL_ELF == 2
+#define STACK_PARAMS   96
+#else
+#define STACK_PARAMS   112
+#endif
+
+#if _CALL_ELF == 2
+        .section ".text"
+        .type   SharedStub,@function
+        .globl  SharedStub
+        # Make the symbol hidden so that the branch from the stub does
+        # not go via a PLT.  This is not only better for performance,
+        # but may be necessary to avoid linker errors since there is
+        # no place to restore the TOC register in a sibling call.
+        .hidden SharedStub
+        .align 2
+SharedStub:
+0:      addis 2,12,(.TOC.-0b)@ha
+        addi 2,2,(.TOC.-0b)@l
+        .localentry SharedStub,.-SharedStub
+#else
         .section ".text"
         .align 2
         .globl SharedStub
@@ -29,6 +50,7 @@ SharedStub:
         .type   SharedStub,@function
 
 .SharedStub:
+#endif
         mflr    r0
 
         std     r4, -56(r1)                     # Save all GPRS
@@ -55,7 +77,7 @@ SharedStub:
 
         subi    r6,r1,56                        # r6 --> gprData
         subi    r7,r1,160                       # r7 --> fprData
-        addi    r5,r1,112                       # r5 --> extra stack args
+        addi    r5,r1,STACK_PARAMS              # r5 --> extra stack args
 
         std     r0, 16(r1)
 	
@@ -75,7 +97,11 @@ SharedStub:
         mtlr    r0
         blr
 
+#if _CALL_ELF == 2
+        .size   SharedStub,.-SharedStub
+#else
         .size   SharedStub,.-.SharedStub
+#endif
 
         # Magic indicating no need for an executable stack
         .section .note.GNU-stack, "", @progbits ; .previous
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_ppc64_linux.cpp
===================================================================
--- mozilla.orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_ppc64_linux.cpp
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_ppc64_linux.cpp
@@ -83,7 +83,9 @@ PrepareAndDispatch(nsXPTCStubBase* self,
                 dp->val.f = (float) fprData[i]; // in registers floats are passed as doubles
             else {
                 float *p = (float *)ap;
+#ifndef __LITTLE_ENDIAN__
                 p++;
+#endif
                 dp->val.f = *p;
             }
         } else { /* integer type or pointer */
@@ -153,6 +155,43 @@ PrepareAndDispatch(nsXPTCStubBase* self,
 // etc.
 // Use assembler directives to get the names right...
 
+#if _CALL_ELF == 2
+# define STUB_ENTRY(n)                                                  \
+__asm__ (                                                               \
+        ".section \".text\" \n\t"                                       \
+        ".align 2 \n\t"                                                 \
+        ".if "#n" < 10 \n\t"                                            \
+        ".globl _ZN14nsXPTCStubBase5Stub"#n"Ev \n\t"                    \
+        ".type  _ZN14nsXPTCStubBase5Stub"#n"Ev,@function \n\n"          \
+"_ZN14nsXPTCStubBase5Stub"#n"Ev: \n\t"                                  \
+        "0: addis 2,12,.TOC.-0b@ha \n\t"                                \
+        "addi     2,2,.TOC.-0b@l \n\t"                                  \
+        ".localentry _ZN14nsXPTCStubBase5Stub"#n"Ev,.-_ZN14nsXPTCStubBase5Stub"#n"Ev \n\t" \
+                                                                        \
+        ".elseif "#n" < 100 \n\t"                                       \
+        ".globl _ZN14nsXPTCStubBase6Stub"#n"Ev \n\t"                    \
+        ".type  _ZN14nsXPTCStubBase6Stub"#n"Ev,@function \n\n"          \
+"_ZN14nsXPTCStubBase6Stub"#n"Ev: \n\t"                                  \
+        "0: addis 2,12,.TOC.-0b@ha \n\t"                                \
+        "addi     2,2,.TOC.-0b@l \n\t"                                  \
+        ".localentry _ZN14nsXPTCStubBase6Stub"#n"Ev,.-_ZN14nsXPTCStubBase6Stub"#n"Ev \n\t" \
+                                                                        \
+        ".elseif "#n" < 1000 \n\t"                                      \
+        ".globl _ZN14nsXPTCStubBase7Stub"#n"Ev \n\t"                    \
+        ".type  _ZN14nsXPTCStubBase7Stub"#n"Ev,@function \n\n"          \
+"_ZN14nsXPTCStubBase7Stub"#n"Ev: \n\t"                                  \
+        "0: addis 2,12,.TOC.-0b@ha \n\t"                                \
+        "addi     2,2,.TOC.-0b@l \n\t"                                  \
+        ".localentry _ZN14nsXPTCStubBase7Stub"#n"Ev,.-_ZN14nsXPTCStubBase7Stub"#n"Ev \n\t" \
+                                                                        \
+        ".else  \n\t"                                                   \
+        ".err   \"stub number "#n" >= 1000 not yet supported\"\n"       \
+        ".endif \n\t"                                                   \
+                                                                        \
+        "li     11,"#n" \n\t"                                           \
+        "b      SharedStub \n"                                          \
+);
+#else
 # define STUB_ENTRY(n)                                                  \
 __asm__ (                                                               \
         ".section \".toc\",\"aw\" \n\t"                                 \
@@ -195,6 +234,7 @@ __asm__ (
         "li     11,"#n" \n\t"                                           \
         "b      SharedStub \n"                                          \
 );
+#endif
 
 #define SENTINEL_ENTRY(n)                                               \
 nsresult nsXPTCStubBase::Sentinel##n()                                  \
